import os
import zipfile
import glob

def distribute_txt_to_others(input_dir):
    # Detecta o arquivo com o padrão *_D_1.zip
    source_zip_list = glob.glob(os.path.join(input_dir, "*_D_1.zip"))
    if not source_zip_list:
        print("Arquivo *_D_1.zip não encontrado.")
        return

    source_zip = source_zip_list[0]

    # Extrair o .txt de *_D_1.zip
    with zipfile.ZipFile(source_zip, 'r') as zip_ref:
        # Assumindo que só há um .txt dentro de *_D_1.zip
        txt_file = [name for name in zip_ref.namelist() if name.endswith('.txt')][0]
        zip_ref.extract(txt_file, input_dir)
        txt_path = os.path.join(input_dir, txt_file)

    # Iterar pelos outros arquivos .zip e adicionar o .txt
    for i in range(2, 10):  # De *_D_2.zip a *_D_9.zip
        prefix = os.path.basename(source_zip).rsplit('_D_1.zip', 1)[0]
        target_zip_path = os.path.join(input_dir, f"{prefix}_D_{i}.zip")
        if os.path.exists(target_zip_path):
            with zipfile.ZipFile(target_zip_path, 'a') as zipf:  # 'a' para adicionar sem remover conteúdo existente
                zipf.write(txt_path, os.path.basename(txt_path))

    # Você pode escolher remover o .txt extraído do diretório ou deixá-lo lá
    # os.remove(txt_path)  # Descomente esta linha se você quiser remover o .txt extraído

if __name__ == "__main__":
    directory = input("Digite o diretório contendo os arquivos .zip: ")
    distribute_txt_to_others(directory)
