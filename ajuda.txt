Claro! Vamos estender a nossa estrutura anterior para criar uma implementação completa para cada tipo de `ResultadoMRI`. 

Primeiro, vamos estabelecer uma estrutura para o `Subprotocolo`. Para simplificar, vou usar alguns campos básicos:

```java
public class Subprotocolo {
    private String motivoSituacao;
    private String descricaoSituacao;
    private DecisaoMRI decisaoMRI;

    // Getters, setters e outros campos/funcionalidades
}

public class DecisaoMRI {
    private String requestId;
    private Date dataRecebimentoCallback;
    private ResultadoMRI decisao;
    private String descricaoDecisao;

    // Getters, setters e outros campos/funcionalidades
}
```

public class ServicoMRI {
    
    private final Map<ResultadoMRI, EstrategiaMRI> estrategias = new HashMap<>();
    private final SubprotocoloService subprotocoloService;

    public ServicoMRI(SubprotocoloService subprotocoloService) {
        this.subprotocoloService = subprotocoloService;

        estrategias.put(ResultadoMRI.APROVAR, new AprovarMRI());
        estrategias.put(ResultadoMRI.INCONCLUSIVO, new InconclusivoMRI());
        estrategias.put(ResultadoMRI.RECUSAR, new RecusarMRI());
        estrategias.put(ResultadoMRI.FUP, new FupMRI());
    }

    public void processarResultadoMRI(ResultadoMRI resultadoMRI, Long subprotocoloId, String descricaoDecisao) {
        Subprotocolo subprotocolo = subprotocoloService.buscarPorId(subprotocoloId);
        if (subprotocolo == null) {
            throw new IllegalArgumentException("Subprotocolo com ID " + subprotocoloId + " não encontrado.");
        }

        EstrategiaMRI estrategia = estrategias.get(resultadoMRI);
        if (estrategia != null) {
            estrategia.executar(subprotocolo, descricaoDecisao);
            // Se você precisar persistir mudanças no Subprotocolo, faça-o aqui.
        } else {
            throw new IllegalArgumentException("Resultado MRI não suportado: " + resultadoMRI);
        }
    }
}

Agora, as estratégias:

```java
public class AprovarMRI implements EstrategiaMRI {
    @Override
    public void executar(Subprotocolo subprotocolo, String descricaoDecisao) {
        subprotocolo.setMotivoSituacao("APROVADO_MRI");
        subprotocolo.setDescricaoSituacao(descricaoDecisao);
    }
}

public class InconclusivoMRI implements EstrategiaMRI {
    @Override
    public void executar(Subprotocolo subprotocolo, String descricaoDecisao) {
        subprotocolo.setMotivoSituacao("INCONCLUSIVO_MRI");
        subprotocolo.setDescricaoSituacao(descricaoDecisao);
    }
}

public class RecusarMRI implements EstrategiaMRI {
    @Override
    public void executar(Subprotocolo subprotocolo, String descricaoDecisao) {
        subprotocolo.setMotivoSituacao("RECUSADO_MRI");
        subprotocolo.setDescricaoSituacao(descricaoDecisao);
    }
}

public class FupMRI implements EstrategiaMRI {
    @Override
    public void executar(Subprotocolo subprotocolo, String descricaoDecisao) {
        subprotocolo.setMotivoSituacao("FUP_MRI");
        subprotocolo.setDescricaoSituacao(descricaoDecisao);
        // Aqui você pode adicionar mais lógica específica para atualizar o protocolo e os documentos pendentes
    }
}
```

Lembre-se de que essa é uma implementação simplificada, e há muitos detalhes adicionais que você pode querer adicionar, como a persistência dos dados alterados, tratamento de erros, entre outros.

A abordagem de Estratégia (Strategy) ajuda a separar a lógica de manipulação para cada tipo de resultado em sua própria classe, facilitando a manutenção e extensão no futuro. Se você precisar adicionar mais lógicas ou resultados, basta adicionar novas classes que implementem `EstrategiaMRI` e atualizar o `ServicoMRI` para lidar com eles.
