import csv
import uuid
import yaml

# Função personalizada para manter a ordem de inserção e adicionar aspas
def represent_dict_order(dumper, data):
    return dumper.represent_mapping('tag:yaml.org,2002:map', data.items(), flow_style=False)

# Função personalizada para evitar quebras de linha em strings longas
def represent_str(dumper, data):
    if len(data.splitlines()) > 1:  # verifica se há múltiplas linhas
        return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')
    return dumper.represent_scalar('tag:yaml.org,2002:str', data)

# Registrar as funções personalizadas
yaml.add_representer(dict, represent_dict_order)
yaml.add_representer(str, represent_str)

def csv_to_yaml(csv_filename, yaml_filename):
    with open(csv_filename, mode='r', encoding='utf-8') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=';')  # Especificando o delimitador
        
        # Pular o cabeçalho
        next(csv_reader)
        
        documentos = []
        
        for row in csv_reader:
            documento = {
                'id': str(uuid.uuid4()),
                'enunciado': row[2],  # Terceira coluna
                'tipo': 'DOCUMENTO',
                'tipo_resposta': 'DOCUMENTO',
                'descrição_detalhada': row[3],  # Quarta coluna
                'observacao': row[4],  # Quinta coluna
                'ativa': True,
                'oculta': False,
                'opcional': True if row[5].lower() == 'opcional' else False,  # Convertendo a string para booleano
                'familia_cobertura': row[0]  # Primeira coluna
            }
            documentos.append(documento)
        
        with open(yaml_filename, mode='w', encoding='utf-8') as yaml_file:
            yaml.dump({'documentos': documentos}, yaml_file, default_flow_style=False, allow_unicode=True)

# Exemplo de uso:
csv_to_yaml('seu_arquivo.csv', 'saida.yaml')
